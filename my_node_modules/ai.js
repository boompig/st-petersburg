// @flow

import { Card } from "../js/cards.js";
import { StaticGameData } from "../js/static-data.js";

/**
 * Helpful polyfills
 */

Array.prototype.min = function () {
    return Math.min.apply(null, this);
};

/**
 * The game state used for AI planning. Compact (lossy) game state representation
 * Contains:
 * - number of cards remaining in each deck
 * - cards on the upper and lower boards
 * - the current phase
 * - the state of the current player
 *
 * @param {number[]} decks
 * @param {Card[]} upperBoard
 * @param {Card[]} lowerBoard
 * @param {Card.types} phase
 * @param {Player} player
 *
 */
export function State (decks, upperBoard, lowerBoard, phase, player) {
    // game state
    this.decks = decks;

    this.upperBoard = upperBoard;
    this.lowerBoard = lowerBoard;

    this.phase = phase;

    // player state
    this.player = player;
}

/**
 * @returns {String}
 */
State.prototype.getPhaseName = function () {
    switch (this.phase) {
    case Card.types.WORKER:
        return "WORKER";
    case Card.types.BUILDING:
        return "BUILDING";
    case Card.types.ARISTOCRAT:
        return "ARISTOCRAT";
    case Card.types.UPGRADE:
        return "UPGRADE";
    }
};

/**
 * @returns {String}
 */
State.prototype.toString = function () {
    const cardNames = [];
    for (let i = 0; i < this.player.cards.length; i++) {
        cardNames.push(this.player.cards[i].name);
    }
    const handNames = [];
    for (let i = 0; i < this.player.hand.length; i++) {
        handNames.push(this.player.hand[i].name);
    }
    const upperCards = [];
    for (let i = 0; i < this.upperBoard.length; i++) {
        upperCards.push(this.upperBoard[i].name);
    }
    const lowerCards = [];
    for (let i = 0; i < this.lowerBoard.length; i++) {
        lowerCards.push(this.lowerBoard[i].name);
    }

    return "State(phase=" + this.getPhaseName() + "," +
        "decks=[" + this.decks.join(", ") + "]," +
        "upperBoard=[" + upperCards.join(", ") + "]," +
        "lowerBoard=[" + lowerCards.join(", ") + "]," +
        "cards=[" + cardNames.join(", ") + "]," +
        "hand=[" + handNames.join(", ") + "]," +
        "points=" + this.player.points + ")";
};

State.prototype.clone = function () {
    const deck = this.decks.slice();
    const lowerBoard = this.lowerBoard.slice();
    const upperBoard = this.upperBoard.slice();
    const player = this.player.clone();
    const phase = this.phase;
    return new State(deck, upperBoard, lowerBoard, phase, player);
};

State.prototype.hasNextPhase = function () {
    return this.phase !== Card.types.UPGRADE || this.hasNextRound();
};

/**
 * Return true iff state can deal a next round
 */
State.prototype.hasNextRound = function () {
    return this.decks.min() > 0;
};

/**
 *
 * @param {Move.actions} action
 * @param {Card.locations} location
 * @param {Card} card
 * @param {Card | null} baseCard
 */
export function Move (action, location, card, baseCard) {
    this.action = action;
    this.location = location;
    this.card = card;
    // this is only set for the UPGRADE action
    this.baseCard = baseCard || null;
}

Move.actions = Object.freeze({
    PASS: 1,
    BUY: 2,
    PUT_IN_HAND: 3,
    UPGRADE: 4
});

/**
 * @returns {String}
 */
Move.prototype.getActionName = function () {
    switch (this.action) {
    case Move.actions.PASS:
        return "PASS";
    case Move.actions.BUY:
        return "BUY";
    case Move.actions.PUT_IN_HAND:
        return "PUT_IN_HAND";
    case Move.actions.UPGRADE:
        return "UPGRADE";
    }
};

/**
 * @returns {String}
 */
Move.prototype.getLocationName = function () {
    switch (this.location) {
    case Card.locations.HAND:
        return "HAND";
    case Card.locations.UPPER_BOARD:
        return "UPPER_BOARD";
    case Card.locations.LOWER_BOARD:
        return "LOWER_BOARD";
    }
};

/**
 * @returns {String}
 */
Move.prototype.toString = function () {
    if (this.baseCard) {
        return "Move (action=" + this.getActionName() +
            ", location=" + this.getLocationName() +
            ", card=" + this.card.name +
            ", baseCard=" + this.baseCard.name + ")";
    } else if (this.card && this.location) {
        return "Move (action=" + this.getActionName() +
            ", location=" + this.getLocationName() +
            ", card=" + this.card.name + ")";
    } else {
        return "Move (action=" + this.getActionName() + ")";
    }
};

Move.prototype.equals = function (otherMove) {
    return this.action === otherMove.action &&
            this.location === otherMove.location &&
            ((this.card === null && otherMove.card === null) ||
             (this.card.name === otherMove.card.name)) &&
            ((this.baseCard === null && otherMove.baseCard === null) ||
             (this.baseCard === otherMove.baseCard));
};

export const AI = {};

/**
 * Generate the state in the next phase if player passes in this phase
 * TODO for now do these things:
 *      - take 8 cards off from next deck (just pop them off, don't look at them)
 *      - assume upper board now blank
 *      - score cards from this phase
 *      - move to next phase
 *      - move cards from upper board to lower board
 *      - discard lower board
 *
 * @param {State}
 * @returns {State}
 */
AI.generateNextPhaseState = function (state) {
    const newState = state.clone();
    const player = newState.player;
    let i, card;

    // take 8 cards off next deck
    const currentDeckIndex = StaticGameData.Phases.indexOf(state.phase);
    const nextDeckIndex = (currentDeckIndex + 1) % StaticGameData.Phases.length;
    newState.decks[nextDeckIndex] -= Math.min(8, newState.decks[nextDeckIndex]);

    // eval state by adding points and money for each card in player's cards
    // which corresponds to current state
    for (i = 0; i < player.cards.length; i++) {
        card = player.cards[i];
        if (card.canEvalNow(state.phase)) {
            player.points += card.pointYield;
            player.money += card.coinYield;
        }
    }

    // put the whole upper board onto the lower board
    newState.lowerBoard = newState.upperBoard;
    // empty the upper board
    newState.upperBoard = [];

    // move to next phase
    newState.phase = StaticGameData.Phases[nextDeckIndex];

    return newState;
};

/**
 * Generate successors is a generator over objects of the following form:
 *      { state: <State>, move: <Move> }
 *
 * @param {State} state
 * @returns {{'move': Move, 'state': State}[]}
 */
AI.generateSuccessors = function genSuccessors (state) {
    const player = state.player;
    const successors = [];
    let i, card, newState;

    if (state.hasNextPhase()) {
        const nextPhaseState = AI.generateNextPhaseState(state);
        // pass and go to next round
        successors.push({
            "state": nextPhaseState,
            "move": new Move(Move.actions.PASS, null, null)
        });
    }

    for (i = 0; i < player.hand.length; i++) {
        card = player.hand[i];
        if (card.type === Card.types.UPGRADE) {
            for (let j = 0; j < player.cards.length; j++) {
                if (player.canUpgradeCard(player.cards[j], card)) {
                    newState = state.clone();
                    newState.player.hand.splice(i, 1);
                    newState.player.upgradeCard(player.cards[j], card,
                        Card.locations.HAND);
                    let move = new Move(Move.actions.UPGRADE, Card.locations.HAND,
                        card, player.cards[j]);
                    successors.push({
                        "state": newState,
                        "move": move
                    });
                }
            }
        } else {
            // try buy card in hand
            if (player.canAffordCard(card, Card.locations.HAND)) {
                newState = state.clone();
                newState.player.playCardFromHand(card);
                successors.push({
                    "state": newState,
                    "move": new Move(Move.actions.BUY, Card.locations.HAND, card)
                });
            }
        }
    }

    for (i = 0; i < state.upperBoard.length; i++) {
        card = state.upperBoard[i];
        if (card.type === Card.types.UPGRADE) {
            for (var j = 0; j < player.cards.length; j++) {
                if (player.canUpgradeCard(player.cards[j], card)) {
                    newState = state.clone();
                    newState.upperBoard.splice(i, 1);
                    newState.player.upgradeCard(player.cards[j], card,
                        Card.locations.UPPER_BOARD);
                    let move = new Move(Move.actions.UPGRADE, Card.locations.UPPER_BOARD,
                        card, player.cards[j]);
                    successors.push({
                        "state": newState,
                        "move": move
                    });
                }
            }
        } else {
            // try buy card
            if (player.canAffordCard(card, Card.locations.UPPER_BOARD)) {
                newState = state.clone();
                newState.upperBoard.splice(i, 1);
                newState.player.buyCard(card, Card.locations.UPPER_BOARD);
                successors.push({
                    "state": newState,
                    "move": new Move(Move.actions.BUY, Card.locations.UPPER_BOARD, card)
                });
            }
        }
        // try take card into hand
        if (player.canPutCardInHand()) {
            newState = state.clone();
            newState.upperBoard.splice(i, 1);
            newState.player.putCardInHand(card);
            successors.push({
                "state": newState,
                "move": new Move(Move.actions.PUT_IN_HAND, Card.locations.UPPER_BOARD, card)
            });
        }
    }

    for (i = 0; i < state.lowerBoard.length; i++) {
        card = state.lowerBoard[i];
        // try buy card
        if (card.type === Card.types.UPGRADE) {
            for (let j = 0; j < player.cards.length; j++) {
                if (player.canUpgradeCard(player.cards[j], card)) {
                    newState = state.clone();
                    newState.lowerBoard.splice(i, 1);
                    newState.player.upgradeCard(player.cards[j], card,
                        Card.locations.LOWER_BOARD);
                    let move = new Move(Move.actions.UPGRADE, Card.locations.LOWER_BOARD,
                        card, player.cards[j]);
                    successors.push({
                        "state": newState,
                        "move": move
                    });
                }
            }
        } else {
            if (player.canAffordCard(card, Card.locations.LOWER_BOARD)) {
                newState = state.clone();
                newState.lowerBoard.splice(i, 1);
                newState.player.buyCard(card, Card.locations.LOWER_BOARD);
                successors.push({
                    "state": newState,
                    "move": new Move(Move.actions.BUY, Card.locations.LOWER_BOARD, card)
                });
            }
        }
        // try take card into hand
        if (player.canPutCardInHand()) {
            newState = state.clone();
            newState.lowerBoard.splice(i, 1);
            newState.player.putCardInHand(card);
            successors.push({
                "state": newState,
                "move": new Move(Move.actions.PUT_IN_HAND, Card.locations.LOWER_BOARD, card)
            });
        }
    }
    return successors;
};

/**
 *
 * @param {State} state
 * @returns {number}
 */
AI.numTurnsLeftInGame = function (state) {
    let minDeck = state.decks.min();
    return Math.ceil(minDeck / 8);
};

/**
 *
 * @param {number} phase
 * @returns {number}
 */
AI.nextPhase = function (phase) {
    let idx = StaticGameData.Phases.indexOf(phase);
    return StaticGameData.Phases[(idx + 1) % StaticGameData.Phases.length];
};

/**
 *
 * @param {Player} player
 * @returns {number}
 */
AI.countAristocrats = function (player) {
    const n = player.numUniqueAristocrats();
    return Math.min(n, 10);
};

/**
 * TODO To evaluate a state, run the game through until its conclusion
 * In all subsequent rounds, assume that all the cards will be bought each round
 *
 *
 * @param {State} state
 * @returns {number}
 */
AI.estimateEvalState = function (state) {
    let player = state.player;
    if (player.cards.length === 0 && player.hand.length === 0 &&
        state.upperBoard.length === 0 && state.lowerBoard.length === 0) {
        return player.money / 10;
    } else if (state.upperBoard.length === 0 && state.lowerBoard.length === 0) {
        // this line of reasoning has been fully explored

        let currentPoints = player.points;
        // add up the points that I have in hand + cards from aristocrats
        let potentialPoints = 0;
        let numArr = 0;
        for (let i = 0; i < player.hand.length; i++) {
            potentialPoints += player.hand[i].pointYield;
            if (player.hand[i].type === Card.types.ARISTOCRAT)
                numArr++;
        }
        for (let i = 0; i < player.cards.length; i++) {
            potentialPoints += player.cards[i].pointYield;
            if (player.cards[i].type === Card.types.ARISTOCRAT)
                numArr++;
        }
        potentialPoints *= (AI.numTurnsLeftInGame(state) + 1);
        return currentPoints + potentialPoints + player.money / 10 +
            StaticGameData.scoreAristocrats(numArr);
    } else {
        // this encourages exploration
        return 5000;
    }
};

/**
 *
 * @param {State} state
 * @returns {boolean}
 */
AI.isTerminalState = function (state) {
    return (! state.hasNextPhase());
};

/**
 * Return the number of points the player would get if the game ended right now
 * TODO for now do these things:
 *      - score all the phases which have not been scored
 *      - take off points for cards in hand
 *      - 1 full point for each 10 money (but just dividing by 10 to give bias to more money)
 *
 * @param {State} initialState
 * @returns {number}
 */
AI.evalState = function (initialState) {
    let state = initialState;
    // evaluate all phases until upgrade
    while (state.phase !== Card.types.UPGRADE) {
        state = AI.generateNextPhaseState(state);
    }

    const player = state.player;
    const p = player.points;
    const numAristocrats = AI.countAristocrats(player);
    return p - (player.hand.length * 5) + (player.money / 10) + StaticGameData.scoreAristocrats(numAristocrats);
};

/**
 *
 * @param {State} state
 * @returns {String}
 */
AI.hashState = function (state) {
    const hash = [];
    // game state
    hash.push( state.decks.join(",") );
    hash.push( "T" + state.phase );

    // player state
    const player = state.player;
    // hash points
    hash.push( "P" + player.points );
    hash.push( "M" + player.money );
    const cardNames = [];
    for (let i = 0; i < player.cards.length; i++) {
        cardNames.push(player.cards[i].name);
        //cardNames.push(player.cards[i].hash());
    }
    cardNames.sort();
    hash.push( "C" + cardNames.join(",") );
    const handNames = [];
    for (let i = 0; i < player.hand.length; i++) {
        handNames.push(player.hand[i].name);
        //handNames.push(player.hand[i].hash());
    }
    handNames.sort();
    hash.push( "H" + handNames.join(",") );
    return hash.join("");
};

/**
 *
 * @param {State} startState
 */
AI.BFS = function (startState) {
    "use strict";
    const open = [{ "state": startState, "moveList": [] }];
    let obj, moveList, state, newMoveList, score, hashState;
    let bestScore = 0;
    let bestMoveList = null;
    const visited = new Set();

    while (open.length > 0) {
        obj = open.splice(0, 1)[0];
        moveList = obj.moveList;
        state = obj.state;
        if (AI.isTerminalState(state)) {
            // terminal doesn't mean terminal
            // terminal means we could potentially stop analysis but may be able to do additional actions
            // example: buy a card from the board or hand
            score = AI.evalState(state);
            if (score > bestScore) {
                bestScore = score;
                bestMoveList = moveList;
            }
        }
        // expand the state into successors
        let successors = AI.generateSuccessors(state);
        for (let i = 0; i < successors.length; i++) {
            hashState = AI.hashState(successors[i].state);
            if (AI.estimateEvalState(successors[i].state) <= bestScore) {
                // you suck, don't add to open
                // but don't add to visited either
                // this is not strictly speaking valid
            } else if (visited.has(hashState)) {
                // already visited
            } else {
                visited.add(hashState);
                newMoveList = moveList.slice();
                newMoveList.push(successors[i].move);
                open.push({
                    "state": successors[i].state,
                    "moveList": newMoveList
                });
            }
        }
    }

    if (bestMoveList === null) {
        bestMoveList = [ new Move(Move.actions.PASS, null, null) ];
    }
    return {
        "score": bestScore,
        "move": bestMoveList[0],
        "moveList": bestMoveList,
        "numNodes": visited.size,
    };
};

/**
 * Return the best move
 * @param {State} state
 * @param {String} aiName The particular AI strategy to use
 * @returns The same thing as AI.BFS
 */
AI.analyze = function (state) {
    return AI.BFS(state);
};
