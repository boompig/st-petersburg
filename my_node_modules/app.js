var Card = require("./cards.js").Card;
var Player = require("./player.js").Player;

/**
 * Helpful polyfills
 */

Array.prototype.min = function () {
    return Math.min.apply(null, this);
};


/**
 * The game state which I plan to pass to the AI
 */
function State (decks, upperBoard, lowerBoard, player) {
    // game state
    this.decks = decks;

    this.upperBoard = upperBoard;
    this.lowerBoard = lowerBoard;

    // player state
    this.player = player;
};

State.prototype.clone = function () {
    var deck = this.decks.slice();
    var lowerBoard = this.lowerBoard.slice();
    var upperBoard = this.upperBoard.slice();
    var player = this.player.clone();
    return new State(deck, upperBoard, lowerBoard, player);
};

/**
 * Return true iff state can deal a next round
 */
State.prototype.hasNextRound = function () {
    return this.decks.min() > 0;
};

/**
 * Return the number of points the player would get if the game ended right now
 * TODO for now evaluate all the cards for money and points
 * TODO for now just give points based on player points and # cards in hand
 */
State.prototype.eval = function () {
    var player = this.player;
    var card;
    for (var i = 0; i < player.cards.length; i++) {
        card = player.cards[i];
        player.points += card.pointYield;
        player.coins += card.coinYield;
    }
    var p = this.player.points;
    return p - (this.player.hand.length * 5);
};

function Move (action, location, card) {
    this.action = action;
    this.location = location;
    this.card = card;
};

Move.actions = {
    PASS: 1,
    BUY: 2,
    PUT_IN_HAND: 3
};

Card.locations = {
    HAND: 1,
    UPPER_BOARD: 2,
    LOWER_BOARD: 3
};

Move.prototype.equals = function (otherMove) {
    return this.action === otherMove.action &&
            this.location === otherMove.location &&
            ((this.card === null && otherMove.card === null) ||
             (this.card.name === otherMove.card.name));
};

var AI = {};

/**
 * Generate the state in the next round if player passes in this round
 * TODO for now take off 8 cards from each deck
 */
AI.generateNextRoundState = function (state) {
    var newState = state.clone();
    var player = newState.player;
    var i;

    // remove appropriate amt from decks
    for (i = 0; i < newState.decks.length; i++) {
        newState.decks[i] -= Math.min(8, newState.decks[i]);
    }

    // eval state by adding points and money for each card in player's cards
    for (i = 0; i < player.cards.length; i++) {
        player.points += player.cards[i].pointYield;
        player.coins += player.cards[i].coinYield;
    }

    // put the whole upper board onto the lower board
    newState.lowerBoard = newState.upperBoard;
    // empty the upper board
    newState.upperBoard = [];
    return newState;
};

/**
 * Return an array of possible successor states.
 */
AI.generateSuccessors = function (state) {
    var player = state.player;
    var successors = [];
    var i, card, newState;

    if (state.hasNextRound()) {
        var nextRoundState = AI.generateNextRoundState(state);
        //console.log(nextRoundState);
        // pass and go to next round
        successors.push({
            "state": nextRoundState,
            "move": new Move(Move.actions.PASS, null, null)
        });
    }

    for (i = 0; i < player.hand.length; i++) {
        card = player.hand[i];
        // try buy card in hand
        if (player.canAffordCard(card, Card.locations.HAND)) {
            newState = state.clone();
            newState.player.playCardFromHand(card);
            successors.push({
                "state": newState,
                "move": new Move(Move.actions.BUY, Card.locations.HAND, card)
            });
        }
    }

    for (i = 0; i < state.upperBoard.length; i++) {
        card = state.upperBoard[i];
        // try buy card
        if (player.canAffordCard(card, Card.locations.UPPER_BOARD)) {
            newState = state.clone();
            newState.upperBoard.splice(i, 1);
            newState.player.buyCard(card, Card.locations.UPPER_BOARD);
            successors.push({
                "state": newState,
                "move": new Move(Move.actions.BUY, Card.locations.UPPER_BOARD, card)
            });
        }
        // try take card into hand
        if (player.canPutCardInHand()) {
            newState = state.clone();
            newState.upperBoard.splice(i, 1);
            newState.player.putCardInHand(card);
            successors.push({
                "state": newState,
                "move": new Move(Move.actions.PUT_IN_HAND, Card.locations.UPPER_BOARD, card)
            });
        }
    }

    for (i = 0; i < state.lowerBoard.length; i++) {
        card = state.lowerBoard[i];
        // try buy card
        if (player.canAffordCard(card, Card.locations.LOWER_BOARD)) {
            newState = state.clone();
            newState.lowerBoard.splice(i, 1);
            newState.player.buyCard(card, Card.locations.LOWER_BOARD);
            successors.push({
                "state": newState,
                "move": new Move(Move.actions.BUY, Card.locations.LOWER_BOARD, card)
            });
        }
        // try take card into hand
        if (player.canPutCardInHand()) {
            newState = state.clone();
            newState.lowerBoard.splice(i, 1);
            newState.player.putCardInHand(card);
            successors.push({
                "state": newState,
                "move": new Move(Move.actions.PUT_IN_HAND, Card.locations.LOWER_BOARD, card)
            });
        }
    }
    return successors;
};

AI.numTurnsLeftInGame = function (state) {
    var minDeck = state.decks.min();
    return Math.ceil(minDeck / 8);
};

/**
 * Return the best move
 */
AI.analyze = function (state) {
    var bestScore = 0;
    var bestMove = null;
    var score, newState, move, obj;

    var successorStates = AI.generateSuccessors(state);
    for (var i = 0; i < successorStates.length; i++) {
        newState = successorStates[i].state;
        move = successorStates[i].move;
        obj = AI.analyze(newState);

        if (obj.score > bestScore) {
            bestScore = obj.score;
            bestMove = move;
        }
    }

    // eval the best move
    if (bestMove === null) {
        return {
            "score": state.eval(),
            "move": new Move(Move.actions.PASS, null, null)
        };
    } else {
        // evaluate the move, then evaluate the state
        return {
            "score": bestScore,
            "move": bestMove
        };
    }
};

exports.State = State;
exports.Player = Player;
exports.AI = AI;
exports.Move = Move;
