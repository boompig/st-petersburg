/* global _ */

import { Card } from "../js/cards.js";

/**
 * The game state used for AI planning. Compact (lossy) game state representation
 * Contains:
 * - number of cards remaining in each deck
 * - cards on the upper and lower boards
 * - the current phase
 * - the state of the current player
 *
 * @param {number[]} decks
 * @param {Card[]} upperBoard
 * @param {Card[]} lowerBoard
 * @param {Card.types} phase
 * @param {Player} player
 *
 */
export function State (decks, upperBoard, lowerBoard, phase, player) {
    // game state
    this.decks = decks;

    this.upperBoard = upperBoard;
    this.lowerBoard = lowerBoard;

    this.phase = phase;

    // player state
    this.player = player;
}

/**
 * @returns {String}
 */
State.prototype.getPhaseName = function () {
    switch (this.phase) {
    case Card.types.WORKER:
        return "WORKER";
    case Card.types.BUILDING:
        return "BUILDING";
    case Card.types.ARISTOCRAT:
        return "ARISTOCRAT";
    case Card.types.UPGRADE:
        return "UPGRADE";
    }
};

/**
 * @returns {String}
 */
State.prototype.toString = function () {
    const cardNames = [];
    for (let i = 0; i < this.player.cards.length; i++) {
        cardNames.push(this.player.cards[i].name);
    }
    const handNames = [];
    for (let i = 0; i < this.player.hand.length; i++) {
        handNames.push(this.player.hand[i].name);
    }
    const upperCards = [];
    for (let i = 0; i < this.upperBoard.length; i++) {
        upperCards.push(this.upperBoard[i].name);
    }
    const lowerCards = [];
    for (let i = 0; i < this.lowerBoard.length; i++) {
        lowerCards.push(this.lowerBoard[i].name);
    }

    return "State(phase=" + this.getPhaseName() + "," +
        "decks=[" + this.decks.join(", ") + "]," +
        "upperBoard=[" + upperCards.join(", ") + "]," +
        "lowerBoard=[" + lowerCards.join(", ") + "]," +
        "cards=[" + cardNames.join(", ") + "]," +
        "hand=[" + handNames.join(", ") + "]," +
        "points=" + this.player.points + ")";
};

State.prototype.clone = function () {
    const deck = this.decks.slice();
    const lowerBoard = this.lowerBoard.slice();
    const upperBoard = this.upperBoard.slice();
    const player = this.player.clone();
    const phase = this.phase;
    return new State(deck, upperBoard, lowerBoard, phase, player);
};

State.prototype.hasNextPhase = function () {
    return this.phase !== Card.types.UPGRADE || this.hasNextRound();
};

/**
 * Return true iff state can deal a next round
 */
State.prototype.hasNextRound = function () {
    return _.min(this.decks) > 0;
};
