/* global _ */

import { Card } from "../js/cards.js";
import { StaticGameData } from "../js/static-data.js";

/**
 * The game state used for AI planning. Compact (lossy) game state representation
 * Contains:
 * - number of cards remaining in each deck
 * - cards on the upper and lower boards
 * - the current phase
 * - the state of the current player
 *
 * @param {number[]} decks
 * @param {Card[]} upperBoard Note that this will be modified by the game
 * @param {Card[]} lowerBoard Note that this will be modified by the game
 * @param {Card.types} phase The current game phase
 * @param {Player[]} players All the players for this game
 * @param {number} turn The index of the player whose turn it is
 */
export class State {
    constructor(decks, upperBoard, lowerBoard, phase, players, turn) {
        // game state
        this.decks = decks;

        this.upperBoard = upperBoard;
        this.lowerBoard = lowerBoard;

        this.phase = phase;

        this.players = players;
        this.turn = turn;
    }

    get currentPlayer() {
        return this.players[this.turn];
    }

    /**
     * @returns {String}
     */
    getPhaseName() {
        switch (this.phase) {
        case Card.types.WORKER:
            return "WORKER";
        case Card.types.BUILDING:
            return "BUILDING";
        case Card.types.ARISTOCRAT:
            return "ARISTOCRAT";
        case Card.types.UPGRADE:
            return "UPGRADE";
        }
    }

    /**
     * @returns {String}
     */
    toString() {
        const cardNames = [];
        for (let i = 0; i < this.currentPlayer.cards.length; i++) {
            cardNames.push(this.currentPlayer.cards[i].name);
        }
        const handNames = [];
        for (let i = 0; i < this.currentPlayer.hand.length; i++) {
            handNames.push(this.currentPlayer.hand[i].name);
        }
        const upperCards = [];
        for (let i = 0; i < this.upperBoard.length; i++) {
            upperCards.push(this.upperBoard[i].name);
        }
        const lowerCards = [];
        for (let i = 0; i < this.lowerBoard.length; i++) {
            lowerCards.push(this.lowerBoard[i].name);
        }

        return "State(phase=" + this.getPhaseName() + "," +
            "decks=[" + this.decks.join(", ") + "]," +
            "upperBoard=[" + upperCards.join(", ") + "]," +
            "lowerBoard=[" + lowerCards.join(", ") + "]," +
            "cards=[" + cardNames.join(", ") + "]," +
            "hand=[" + handNames.join(", ") + "]," +
            "points=" + this.currentPlayer.points + ")";
    }

    clone() {
        // copy array
        const deck = this.decks.slice();
        // copy array
        const lowerBoard = this.lowerBoard.slice();
        // copy array
        const upperBoard = this.upperBoard.slice();
        // clone each player in the array
        const players = this.players.map((player) => player.clone());
        return new State(deck, upperBoard, lowerBoard, this.phase, players, this.turn);
    }

    hasNextPhase() {
        return this.phase !== Card.types.UPGRADE || this.hasNextRound();
    }

    /**
     * Return true iff state can deal a next round
     */
    hasNextRound() {
        return _.min(this.decks) > 0;
    }
}